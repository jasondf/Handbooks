<!DOCTYPE html>
<html lang="zh-CN">
<head>
<!-- 2017-08-18 Fri 18:12 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Git Handbook</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Jason Daifei">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel='stylesheet' type='text/css' href='https://cdn.rawgit.com/jasondf/emacs.d/a2444d2c/css/org-mode.css' />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Git Handbook</h1>
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org13272e3">1. Git安装与配置：</a>
<ul>
<li><a href="#orgae9181d">1.1. 安装</a></li>
<li><a href="#orgb9112f1">1.2. 配置</a></li>
<li><a href="#org9c51fe6">1.3. 用户信息</a></li>
<li><a href="#org52fa77f">1.4. 指定文本编辑器</a></li>
<li><a href="#orgd963b1b">1.5. 差异分析工具</a></li>
<li><a href="#org3169f4f">1.6. 查看配置信息</a></li>
<li><a href="#orgb35406e">1.7. 获取帮助</a></li>
</ul>
</li>
<li><a href="#org85f78c6">2. ssh</a>
<ul>
<li><a href="#orgb6e97d0">2.1. 生成ssh</a></li>
<li><a href="#org69944ea">2.2. 将SSH key加入ssh-agent</a></li>
<li><a href="#org32e4970">2.3. 向代码托管网站中中添加ssh</a></li>
<li><a href="#orgb839f05">2.4. 测试连接</a></li>
<li><a href="#org86d9d3b">2.5. 如果连接报错</a></li>
</ul>
</li>
<li><a href="#orgb27ff92">3. Git操作</a>
<ul>
<li><a href="#org19cb882">3.1. git远程操作命令讲解</a>
<ul>
<li><a href="#org6b2c0d3">3.1.1. git clone</a></li>
<li><a href="#orge3e1b52">3.1.2. git remote</a></li>
<li><a href="#org3d8a5b4">3.1.3. git fetch</a></li>
<li><a href="#orgc4524b7">3.1.4. git pull</a></li>
<li><a href="#org8618806">3.1.5. git push</a></li>
</ul>
</li>
<li><a href="#orgb8c5d82">3.2. 实际应用示例</a></li>
<li><a href="#org6d16955">3.3. 忽略一些文件，不push的方法</a></li>
<li><a href="#org1c9abdc">3.4. 创建一个branch</a></li>
<li><a href="#orgf9e722c">3.5. merge更改</a></li>
<li><a href="#orga29845e">3.6. 撤销未commit的更改</a></li>
<li><a href="#orgd6a5f6e">3.7. 对已经commit过的数据进行修正</a></li>
<li><a href="#org208dfe8">3.8. 冲突处理</a>
<ul>
<li><a href="#org9a2c81b">3.8.1. 查看变更</a></li>
<li><a href="#org42523a9">3.8.2. stash</a></li>
</ul>
</li>
<li><a href="#orgfd4554d">3.9. 疑难问题分析和解决</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org13272e3" class="outline-2">
<h2 id="org13272e3"><span class="section-number-2">1</span> Git安装与配置：</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-orgae9181d" class="outline-3">
<h3 id="orgae9181d"><span class="section-number-3">1.1</span> 安装</h3>
<div class="outline-text-3" id="text-1-1">
<pre class="example">
$ brew install git #用homebrew安装git
$ git --version #查看git版本
$ git --status #查看git状态
</pre>
</div>
</div>

<div id="outline-container-orgb9112f1" class="outline-3">
<h3 id="orgb9112f1"><span class="section-number-3">1.2</span> 配置</h3>
<div class="outline-text-3" id="text-1-2">
<p>
配置变量可以存放在以下三个不同的地方：<br>
</p>
<ol class="org-ol">
<li>"/etc/gitconfig"文件：系统中对所有用户都普遍适用的配置。若使用git config命令时用&#x2013;system选项，读写的就是这个文件。<br></li>
<li>"~/.gitconfig"文件：用户目录下的配置文件只适用于该用户。若使用git config命令时用&#x2013;global选项，读写的就是这个文件。<br></li>
<li>当前项目的Git目录中的配置文件，也就是工作目录中的".git/config"文件：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以".git/config"里的配置会覆盖"/etc/gitconfig"中的同名变量。<br></li>
<li>在Windows系统上Git会找寻用户主目录下的".gitconfig"文件。主目录即$HOME变量指定的目录，一般都是 C:\Documents and Settings\$USER。<br></li>
</ol>
</div>
</div>

<div id="outline-container-org9c51fe6" class="outline-3">
<h3 id="org9c51fe6"><span class="section-number-3">1.3</span> 用户信息</h3>
<div class="outline-text-3" id="text-1-3">
<pre class="example">
$ git config --global user.name "Jasondf"
$ git config --global user.email jason.daifei@gmail.com
</pre>

<p>
如果用了&#x2013;global选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉&#x2013;global选项重新配置即可，新的设定保存在当前项目的".git/config"文件里。<br>
</p>
</div>
</div>

<div id="outline-container-org52fa77f" class="outline-3">
<h3 id="org52fa77f"><span class="section-number-3">1.4</span> 指定文本编辑器</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Git需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器。<br>
</p>

<pre class="example">
$ git config --global core.editor emacs
</pre>
</div>
</div>

<div id="outline-container-orgd963b1b" class="outline-3">
<h3 id="orgd963b1b"><span class="section-number-3">1.5</span> 差异分析工具</h3>
<div class="outline-text-3" id="text-1-5">
<p>
还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用vimdiff的话：<br>
</p>

<pre class="example">
$ git config --global merge.tool vimdiff
</pre>

<p>
Git可以理解kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。<br>
</p>
</div>
</div>

<div id="outline-container-org3169f4f" class="outline-3">
<h3 id="org3169f4f"><span class="section-number-3">1.6</span> 查看配置信息</h3>
<div class="outline-text-3" id="text-1-6">
<p>
要检查已有的配置信息，可以使用：<br>
</p>

<pre class="example">
$ git config --list
</pre>

<p>
也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：<br>
</p>

<pre class="example">
$ git config user.name
Jasondf
</pre>
</div>
</div>

<div id="outline-container-orgb35406e" class="outline-3">
<h3 id="orgb35406e"><span class="section-number-3">1.7</span> 获取帮助</h3>
<div class="outline-text-3" id="text-1-7">
<p>
方法有三：<br>
</p>

<pre class="example">
$ git help &lt;verb&gt;
$ git &lt;verb&gt; --help
$ man git-&lt;verb&gt;
</pre>

<p>
比如，要学习config命令可以怎么用，运行：<br>
</p>

<pre class="example">
$ git help config
</pre>
</div>
</div>
</div>

<div id="outline-container-org85f78c6" class="outline-2">
<h2 id="org85f78c6"><span class="section-number-2">2</span> ssh</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-orgb6e97d0" class="outline-3">
<h3 id="orgb6e97d0"><span class="section-number-3">2.1</span> 生成ssh</h3>
<div class="outline-text-3" id="text-2-1">
<p>
*注意：*与ssh相关的命令都要用操作系统的原生命令，不要用自己通过homebrew之类的包管理软件所添加的。<br>
</p>

<pre class="example">
$ ssh-keygen -t rsa -b 4096 -C "jason.daifei@icloud.com"
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/jason/.ssh/id_rsa):[直接enter]
Created directory '/Users/jason/.ssh'.
Enter passphrase (empty for no passphrase): [设置此key的密码]
Enter same passphrase again:[再次确认密码]
Your identification has been saved in /Users/jason/.ssh/id_rsa.
Your public key has been saved in /Users/jason/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:882GZfRcX6u+Hd5a3ZngE9Z27C7PI0MJ4amQ8pK6kqw jason.daifei@icloud.com
The key's randomart image is:
+---[RSA 4096]----+
|                 |
|           .     |
|        . . +   o|
|     . o   = o.o+|
|      + S . +++++|
|     o . + *oo=.*|
|. . . .   o =+ +=|
| + .       ..o==o|
|E ...        o=**|
+----[SHA256]-----+
</pre>
</div>
</div>

<div id="outline-container-org69944ea" class="outline-3">
<h3 id="org69944ea"><span class="section-number-3">2.2</span> 将SSH key加入ssh-agent</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>在后台启动ssh-agent：<br></li>
</ol>

<div class="org-src-container">
<pre class="src src-shell">$ eval <span style="color: #e9967a;">"$(</span><span style="color: #fa8072;">ssh-agent</span><span style="color: #e9967a;"> -s)"</span> <span style="color: #ff7f24;">#</span><span style="color: #ff7f24;">&#27880;&#24847;&#65292;&#27492;&#21629;&#20196;&#22312;emacs&#30340;eshell&#20013;&#25191;&#34892;&#20250;&#25253;&#38169;&#12290;</span>
</pre>
</div>

<ol class="org-ol">
<li>如果是macOS Sierra 10.12.2或是更新的系统，需要修改"~/.ssh/config"文件以自动向ssh-agent加载密匙并将密码存储在keychain中。<br></li>
</ol>

<div class="org-src-container">
<pre class="src src-text">Host *
 AddKeysToAgent yes
 UseKeychain yes
 IdentityFile ~/.ssh/id_rsa
</pre>
</div>

<ol class="org-ol">
<li>将SSH私有密匙添加至ssh-agent并将密码存储至keychain。<br></li>
</ol>

<div class="org-src-container">
<pre class="src src-shell">$ ssh-add -K ~/.ssh/id_rsa
</pre>
</div>
</div>
</div>

<div id="outline-container-org32e4970" class="outline-3">
<h3 id="org32e4970"><span class="section-number-3">2.3</span> 向代码托管网站中中添加ssh</h3>
<div class="outline-text-3" id="text-2-3">
<p>
在复制公有密匙内容的时候，为防止有的编辑器自动向文档内容中添加其他内容，可以使用下面的命令将密匙内容复制到剪贴板。<br>
</p>

<div class="org-src-container">
<pre class="src src-shell">$ pbcopy &lt; ~/.ssh/id_rsa.pub
</pre>
</div>

<pre class="example">
github.com:
Edit profile -&gt; SSH keys -&gt; Add SSH key
title: jasonMBP
将id_rsa.pub中的内容复制进去。
</pre>

<pre class="example">
bitbucket.org:
Bitbucket settings -&gt; SSH keys -&gt; Add key
</pre>
</div>
</div>

<div id="outline-container-orgb839f05" class="outline-3">
<h3 id="orgb839f05"><span class="section-number-3">2.4</span> 测试连接</h3>
<div class="outline-text-3" id="text-2-4">
<pre class="example">
github.com:
$ ssh -T git@github.com
</pre>

<p>
如果出现"Hi Jasondf!&#x2026;"表示已经连接成功。<br>
</p>

<pre class="example">
bitbucket.org:
$ ssh -T git@bitbucket.org
</pre>

<p>
如果出现"logged in as jasondf."表示连接成功。<br>
</p>
</div>
</div>

<div id="outline-container-org86d9d3b" class="outline-3">
<h3 id="org86d9d3b"><span class="section-number-3">2.5</span> 如果连接报错</h3>
<div class="outline-text-3" id="text-2-5">
<p>
如果出现错误提示：Permission denied (publickey).因为新生成的key不能加入ssh就会导致连接不上。<br>
</p>

<pre class="example">
1. 先输入$ ssh-agent，再输入$ ssh-add ~/.ssh/id_rsa，这样就可以了。
2. 如果输入$ ssh-add ~/.ssh/id_rsa 命令后出现报错Could not open a connection to your authentication agent.
 解决方法是key用Git Gui的ssh工具生成，这样生成的时候key就直接保存在ssh中了，不需要再ssh-add命令加入了，其它的user，token等配置都用命令行来做。
3. 最好检查一下在你复制id_rsa.pub文件的内容时有没有产生多余的空格或空行，有些编辑器会帮你添加这些的。
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb27ff92" class="outline-2">
<h2 id="orgb27ff92"><span class="section-number-2">3</span> Git操作</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-org19cb882" class="outline-3">
<h3 id="org19cb882"><span class="section-number-3">3.1</span> git远程操作命令讲解</h3>
<div class="outline-text-3" id="text-3-1">

<div class="figure">
<p><img src="./gitremoteops.jpg" alt="gitremoteops.jpg"><br>
</p>
</div>
</div>

<div id="outline-container-org6b2c0d3" class="outline-4">
<h4 id="org6b2c0d3"><span class="section-number-4">3.1.1</span> git clone</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。<br>
</p>

<pre class="example">
$ git clone &lt;版本库的网址&gt;
</pre>

<p>
例如，克隆iBetterCare的版本库：<br>
</p>

<pre class="example">
$ git clone git@bitbucket.org:jasondf/ibettercare.git
</pre>

<p>
该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。<br>
</p>

<pre class="example">
$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;
</pre>
</div>
</div>

<div id="outline-container-orge3e1b52" class="outline-4">
<h4 id="orge3e1b52"><span class="section-number-4">3.1.2</span> git remote</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。<br>
不带选项的时候，git remote命令列出所有远程主机：<br>
</p>

<pre class="example">
$ git remote
origin
</pre>

<p>
使用-v选项，可以参看远程主机的网址：<br>
</p>

<pre class="example">
$ git remote -v
origin	ssh://git@bitbucket.org/jasondf/ibettercare.git (fetch)
origin	ssh://git@bitbucket.org/jasondf/ibettercare.git (push)
</pre>

<p>
上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。<br>
克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定:<br>
</p>

<pre class="example">
$ git clone -o jQuery https://github.com/jquery/jquery.git
$ git remote
jQuery
</pre>

<p>
上面命令表示，克隆的时候，指定远程主机叫做jQuery。<br>
git remote show命令加上主机名，可以查看该主机的详细信息:<br>
</p>

<pre class="example">
$ git remote show &lt;主机名&gt;
</pre>

<p>
git remote add命令用于添加远程主机:<br>
</p>

<pre class="example">
$ git remote add &lt;主机名&gt; &lt;网址&gt;
</pre>

<p>
git remote rm命令用于删除远程主机:<br>
</p>

<pre class="example">
$ git remote rm &lt;主机名&gt;
</pre>

<p>
git remote rename命令用于远程主机的改名:<br>
</p>

<pre class="example">
$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;
</pre>
</div>
</div>

<div id="outline-container-org3d8a5b4" class="outline-4">
<h4 id="org3d8a5b4"><span class="section-number-4">3.1.3</span> git fetch</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。<br>
</p>

<pre class="example">
$ git fetch &lt;远程主机名&gt;
</pre>

<p>
上面命令将某个远程主机的更新，全部取回本地。<br>
git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。<br>
默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名：<br>
</p>

<pre class="example">
$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;
</pre>

<p>
比如，取回origin主机的master分支：<br>
</p>

<pre class="example">
$ git fetch origin master
</pre>

<p>
所取回的更新，在本地主机上要用"远程主机名/分支名"的形式读取。比如origin主机的master，就要用origin/master读取。<br>
git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。<br>
</p>

<pre class="example">
$ git branch -r
origin/master
$ git branch -a
* master
remotes/origin/master
</pre>

<p>
上面命令表示，本地主机的当前分支是master，远程分支是origin/master。<br>
取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支：<br>
</p>

<pre class="example">
$ git checkout -b newBrach origin/master
</pre>

<p>
上面命令表示，在origin/master的基础上，创建一个新分支。<br>
此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。<br>
</p>

<pre class="example">
$ git merge origin/master
# 或者
$ git rebase origin/master
</pre>

<p>
上面命令表示在当前分支上，合并origin/master。<br>
</p>
</div>
</div>

<div id="outline-container-orgc4524b7" class="outline-4">
<h4 id="orgc4524b7"><span class="section-number-4">3.1.4</span> git pull</h4>
<div class="outline-text-4" id="text-3-1-4">
<p>
git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。命令格式为：<br>
</p>

<pre class="example">
$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</pre>

<p>
比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样：<br>
</p>

<pre class="example">
$ git pull origin next:master
</pre>

<p>
如果远程分支是与当前分支合并，则冒号后面的部分可以省略：<br>
</p>

<pre class="example">
$ git pull origin next
</pre>

<p>
上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge：<br>
</p>

<pre class="example">
$ git fetch origin
$ git merge origin/next
</pre>

<p>
在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动"追踪"origin/master分支。<br>
Git也允许手动建立追踪关系：<br>
</p>

<pre class="example">
$ git branch --set-upstream master origin/next
</pre>

<p>
上面命令指定master分支追踪origin/next分支。<br>
如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名：<br>
</p>

<pre class="example">
$ git pull origin
</pre>

<p>
上面命令表示，本地的当前分支自动与对应的origin主机"追踪分支"（remote-tracking branch）进行合并。<br>
如果当前分支只有一个追踪分支，连远程主机名都可以省略：<br>
</p>

<pre class="example">
$ git pull
</pre>

<p>
上面命令表示，当前分支自动与唯一一个追踪分支进行合并。<br>
如果合并需要采用rebase模式，可以使用&#x2013;rebase选项：<br>
</p>

<pre class="example">
$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;
</pre>

<p>
如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。<br>
但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支：<br>
</p>

<pre class="example">
$ git pull -p
# 等同于下面的命令
$ git fetch --prune origin 
$ git fetch -p
</pre>
</div>
</div>

<div id="outline-container-org8618806" class="outline-4">
<h4 id="org8618806"><span class="section-number-4">3.1.5</span> git push</h4>
<div class="outline-text-4" id="text-3-1-5">
<p>
git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。<br>
</p>

<pre class="example">
$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
</pre>

<p>
注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。<br>
如果省略远程分支名，则表示将本地分支推送与之存在"追踪关系"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建：<br>
</p>

<pre class="example">
$ git push origin master
</pre>

<p>
上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。<br>
如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支：<br>
</p>

<pre class="example">
$ git push origin :master
# 等同于
$ git push origin --delete master
</pre>

<p>
上面命令表示删除origin主机的master分支。<br>
如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略：<br>
</p>

<pre class="example">
$ git push origin
</pre>

<p>
上面命令表示，将当前分支推送到origin主机的对应分支。<br>
如果当前分支只有一个追踪分支，那么主机名都可以省略：<br>
</p>

<pre class="example">
$ git push
</pre>

<p>
如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push：<br>
</p>

<pre class="example">
$ git push -u origin master
</pre>

<p>
上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。<br>
不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令：<br>
</p>

<pre class="example">
$ git config --global push.default matching
# 或者
$ git config --global push.default simple
</pre>

<p>
还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用&#x2013;all选项：<br>
</p>

<pre class="example">
$ git push --all origin
</pre>

<p>
上面命令表示，将所有本地分支都推送到origin主机。<br>
如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用&#x2013;force选项：<br>
</p>

<pre class="example">
$ git push --force origin
</pre>

<p>
上面命令使用&#x2013;force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用&#x2013;force选项。<br>
最后，git push不会推送标签（tag），除非使用&#x2013;tags选项：<br>
</p>

<pre class="example">
$ git push origin --tags
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb8c5d82" class="outline-3">
<h3 id="orgb8c5d82"><span class="section-number-3">3.2</span> 实际应用示例</h3>
<div class="outline-text-3" id="text-3-2">
<p>
本文以本地的"~/projects/iBetterCare"项目为示例。<br>
</p>

<ul class="org-ul">
<li>如果在代码托管网站(github.com或者bitbucket.org)中还没有相对应的repository，则需要创建一个名称为iBetterCare的repository；<br></li>

<li><p>
进入项目根目录并初始化本地仓库:<br>
</p>

<pre class="example">
$ cd ~/projects/iBetterCare 
$ git init
</pre>

<p>
此时在iBetterCare文件夹中会新建一个".git"目录。<br>
</p></li>

<li><p>
连接远程repository并创建一个叫origin的别名：(在两个网站中的用户名都是"jasondf")<br>
</p>

<pre class="example">
github.com：
$ git remote add origin ssh://github.com/jasondf/iBetterCare.git 
bitbucket.org：
$ git remote add origin ssh://git@bitbucket.org/jasondf/ibettercare.git
</pre></li>

<li><p>
如果需要先将远程repository的代码clone到本地：<br>
</p>

<pre class="example">
$ git clone git@bitbucket.org:jasondf/ibettercare.git
</pre></li>

<li>如果需要将本地代码push至repository：<br>

<ul class="org-ul">
<li><p>
添加(stage)本地项目根目录，表示已经开始跟踪这个文件/目录了：<br>
</p>

<pre class="example">
$ git add .
</pre></li>

<li><p>
添加所有的更改：<br>
</p>

<pre class="example">
$ git add --all
</pre></li>

<li><p>
提交要推送的内容及注释：<br>
</p>

<pre class="example">
$ git commit -m 'initial commit'
</pre></li>

<li><p>
将本地仓库的内容推送到地址是origin的地址，master分支下：<br>
</p>

<pre class="example">
$ git push -u origin master
</pre></li>
</ul></li>
</ul>

<p>
ps,期间可以使用git status来查看状态。<br>
</p>
</div>
</div>

<div id="outline-container-org6d16955" class="outline-3">
<h3 id="org6d16955"><span class="section-number-3">3.3</span> 忽略一些文件，不push的方法</h3>
<div class="outline-text-3" id="text-3-3">
<p>
在本地项目根目录下创建名称为".gitignore"的文件，写入不需要的文件夹名或文件，每个元素占一行即可。例如：<br>
</p>

<pre class="example">
*.[oa]
告诉Git忽略所有以".o"或".a"结尾的文件。
一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。
</pre>

<pre class="example">
*~
告诉Git忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。
此外，你可能还需要忽略log，tmp或者pid目录，以及自动生成的文档等等。
要养成一开始就设置好".gitignore"文件的习惯，以免将来误提交这类无用的文件。
</pre>

<pre class="example">
"#"为注释，其后内容将被Git忽略
</pre>

<pre class="example">
*DS_Store
/**/*DS_Store
忽略所有的.DS_Store文件
</pre>

<pre class="example">
*.a
忽略所有 .a 结尾的文件
</pre>

<pre class="example">
!lib.a
但lib.a除外
</pre>

<pre class="example">
/TODO
仅仅忽略项目根目录下的TODO文件，不包括subdir/TODO
</pre>

<pre class="example">
build/
忽略 build/ 目录下的所有文件
</pre>

<pre class="example">
doc/*.txt
忽略 doc/notes.txt 但不包括 doc/server/arch.txt
</pre>

<pre class="example">
doc/**/*.txt
忽略 doc/ 目录下所有扩展名为 txt 的文件
</pre>
</div>
</div>

<div id="outline-container-org1c9abdc" class="outline-3">
<h3 id="org1c9abdc"><span class="section-number-3">3.4</span> 创建一个branch</h3>
<div class="outline-text-3" id="text-3-4">
<p>
创建branch可以向还未做好提交准备的代码进行更改。在准备好让所有人知晓代码更改的时候，可以merge修改到repository，并且删除不再需要的branch。需要理解的是，branch只是用于commit操作的指针。创建一个branch的时候，Git只会创建一个新的指针，而不是把所有的文件和文件夹都新创建一遍。<br>
</p>

<p>
至项目根目录：<br>
</p>

<pre class="example">
$ cd ~/projects/iBetterCare
</pre>

<p>
创建一个分支：<br>
</p>

<pre class="example">
$ git branch developing
</pre>

<p>
此时只是创建了一个developing branch，但是并没有将你切换至该branch。此时repository的历史没有发生改变。我们所得到的只是一个指向当前branch的指针。要想在新的branch上开始工作，则需要对想使用的branch进行检出。<br>
</p>

<p>
检出分支并开始使用：<br>
</p>

<pre class="example">
$ git checkout developing
</pre>

<p>
此时会显示：Switched to branch 'developing'。如果用git status命令查看，会显示：On branch developing。<br>
对项目中的文件进行修改并保存。<br>
</p>

<p>
用git status查看状态：<br>
</p>

<pre class="example">
On branch developing
Changes not staged for commit:
    (use "git add &lt;file&gt;..." to update what will be committed)
    (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   app/models/BaseDataInit.java

    no changes added to commit (use "git add" and/or "git commit -a")
</pre>

<p>
注意第一行的"On branch developing"。在stage或是commit变更之前，总是要检查这一行，确保你要对其进行更改的branch已经被检出。<br>
</p>

<p>
添加文件(stage)：<br>
</p>

<pre class="example">
$ git add .
</pre>

<p>
commit更改：<br>
</p>

<pre class="example">
$ git commit . -m 'making a change in a branch'
[developing dce46bc] making change in a branch
1 file changed, 2 insertions(+)
</pre>

<p>
现在可以将所做的修改merge到master分支了。<br>
</p>
</div>
</div>

<div id="outline-container-orgf9e722c" class="outline-3">
<h3 id="orgf9e722c"><span class="section-number-3">3.5</span> merge更改</h3>
<div class="outline-text-3" id="text-3-5">
<p>
切换至master分支:<br>
</p>

<pre class="example">
$ git checkout master
</pre>

<p>
将developing分支的更改merge到master分支:<br>
</p>

<pre class="example">
$ git merge developing
</pre>

<p>
查看分支：<br>
</p>

<pre class="example">
 本地：$ git branch
 所有：$ git branch -a
</pre>

<p>
如果以后不会使用developing分支的话，可以将其删除:<br>
</p>

<pre class="example">
本地：
$ git branch -d developing (-D表示强制删除)
远程：
$ git push origin :developing
</pre>

<p>
现在本地的Local/master分支和远端的Origin/master分支是不一致的，可以通过git push origin master命令将本地master分支中的更改push到网站的master分支了。<br>
</p>
</div>
</div>

<div id="outline-container-orga29845e" class="outline-3">
<h3 id="orga29845e"><span class="section-number-3">3.6</span> 撤销未commit的更改</h3>
<div class="outline-text-3" id="text-3-6">
<p>
撤销unstaged的更改(还没有使用git add进行stage操作)<br>
</p>

<pre class="example">
  撤销项目中所有更改：
     git checkout -- .
  撤销指定文件的更改：
     git checkout -- &lt;file&gt;...
</pre>

<p>
撤销staged的更改(已经使用过git add进行了stage操作)<br>
</p>

<pre class="example">
1. git reset HEAD &lt;file&gt;...或者git reset HEAD .
2. git checkout -- . 或者git checkout -- &lt;file&gt;...
</pre>
</div>
</div>

<div id="outline-container-orgd6a5f6e" class="outline-3">
<h3 id="orgd6a5f6e"><span class="section-number-3">3.7</span> 对已经commit过的数据进行修正</h3>
</div>




<div id="outline-container-org208dfe8" class="outline-3">
<h3 id="org208dfe8"><span class="section-number-3">3.8</span> 冲突处理</h3>
<div class="outline-text-3" id="text-3-8">
</div><div id="outline-container-org9a2c81b" class="outline-4">
<h4 id="org9a2c81b"><span class="section-number-4">3.8.1</span> 查看变更</h4>
<div class="outline-text-4" id="text-3-8-1">
<div class="org-src-container">
<pre class="src src-shell">$ git diff
</pre>
</div>
</div>
</div>

<div id="outline-container-org42523a9" class="outline-4">
<h4 id="org42523a9"><span class="section-number-4">3.8.2</span> stash</h4>
<div class="outline-text-4" id="text-3-8-2">
<p>
开发人员常常遇到这种情况：花了几天时间一直在做一个新功能，已经改了差不多十几个文件，突然有一个bug需要紧急解决，然后给一个build测试组。之前基本上靠手动备份，费时且容易出错。<br>
git stash命令简而言之就是帮助开发人员暂时搁置当前已做的改动，倒退到改动前的状态，进行其他的必要操作（比如发布，或者解决一个bug，或者branch，等等），之后还可以重新载入之前搁置的改动。<br>
</p>

<pre class="example">
1. 把所有的改动加到staging area。
 $ git add .
2. 搁置变更
 $ git stash
到这里，当前工作平台就回复到改动之前了。该干嘛干嘛。
……
3. 需要找回之前搁置的改动继续先前的工作了？
 $ git stash apply
4. 查看所有的搁置版本（可能搁置了很多次，最好不要这样，容易搞混）：
 $ git stash list 
5. 在出现一个搁置栈的情况下，比如如果你想找回栈中的第2个：
 $ git stash apply stash@{1}
6. 如果想找回第1个：
 $ git stash pop
7. 删除一个stash：
 $ git stash drop &lt;id&gt;
8. 删除所有stash：
 $ git stash clear
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfd4554d" class="outline-3">
<h3 id="orgfd4554d"><span class="section-number-3">3.9</span> 疑难问题分析和解决</h3>
<div class="outline-text-3" id="text-3-9">
<pre class="example">
如果输入$ git remote add origin ssh://git@bitbucket.org/jasondf/ibettercare.git提示出错信息：fatal: remote origin already exists.
   1) 先输入：$ git remote rm origin
   2) 再输入：$ git remote add origin ssh://git@bitbucket.org/jasondf/ibettercare.git就不会报错了！
</pre>

<pre class="example">
如果输入$ git push origin master提示出错信息：error:failed to push som refs to .......
   1) 先输入$ git pull origin master 把远程服务器上的文件拉下来
   2) 再输入$ git push origin master
   3) 如果出现报错 fatal: Couldn't find remote ref master
      或者fatal: 'origin' does not appear to be a git repository
      以及fatal: Could not read from remote repository. 
      则需要重新输入：$ git remote add origin ssh://git@bitbucket.org/jasondf/ibettercare.git
</pre>
</div>
</div>
</div>
</div>
</body>
</html>
